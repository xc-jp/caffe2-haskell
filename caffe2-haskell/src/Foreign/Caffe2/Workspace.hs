{-# LANGUAGE CPP             #-}
{-# LANGUAGE QuasiQuotes     #-}
{-# LANGUAGE TemplateHaskell #-}

module Foreign.Caffe2.Workspace where

import ClassyPrelude hiding (Vector)

import Foreign.Marshal.Array (peekArray)
import Foreign.Ptr (Ptr)
import qualified Language.C.Inline.Cpp as C

C.context (C.cppCtx <> C.funCtx <> C.vecCtx <> C.bsCtx)

C.include "<iostream>"
C.include "<caffe2/core/init.h>"
C.include "<caffe2/core/net.h>"
C.include "<caffe2/core/operator.h>"
C.include "<caffe2/core/operator_gradient.h>"
C.include "<caffe2/proto/caffe2.pb.h>"
C.include "<google/protobuf/message.h>"
C.include "<google/protobuf/message_lite.h>"
C.include "<google/protobuf/text_format.h>"

C.using "namespace caffe2"

----------------------------------------------------------------------------
-- Workspace

-- | Opaque wrapper for information that is necessary two interact with
-- Caffe2.

newtype Workspace = Workspace (Ptr ())
  deriving (Show)

newtype BlobPtr = BlobPtr (Ptr ())
  deriving (Show)

newtype NetworkPtr = NetworkPtr (Ptr ())
  deriving (Show)

-- | Initialize 'Workspace'

initWorkspace :: IO Workspace
initWorkspace =
  Workspace <$> [C.block| void* {
    int argc = 0;
    char **argv = {};
    caffe2::GlobalInit(&argc, &argv);
    Workspace *workspace = new Workspace();
    return workspace;
  } |]

-- | Free 'Workspace'

freeWorkspace :: Workspace -> IO ()
freeWorkspace (Workspace workspace) =
  [C.block| void {
    Workspace *workspace = static_cast<Workspace *>($(void * workspace));
    for (auto blob : workspace->Blobs()) {
      workspace->RemoveBlob(blob);
    }
    for (auto net : workspace->Nets()) {
      workspace->DeleteNet(net);
    }
  } |]

-- | Verify whether a blob by specified name is present in the 'Workspace'

hasBlob
  :: Workspace                  -- ^ 'Workspace'
  -> Text                       -- ^ Tensor name
  -> IO Bool
hasBlob (Workspace workspace) name = do
  i <- [C.block| int {
    Workspace * workspace = static_cast<Workspace *>($(void * workspace));
    std::string name($bs-ptr:nameBytes, $bs-len:nameBytes);
    return workspace->HasBlob(name);
  } |]
  pure (i == 1)
    where
    nameBytes = encodeUtf8 name

-- | Create a new blob and add it to the 'Workspace'

createBlob :: Workspace -> Text -> IO BlobPtr
createBlob (Workspace workspace) name =
  BlobPtr <$> [C.block| void* {
    Workspace *workspace = static_cast<Workspace *>($(void *workspace));
    std::string name($bs-ptr:blobName, $bs-len:blobName);
    Blob *blob = workspace->CreateBlob(name);
    return blob;
  }|]
    where
      blobName = encodeUtf8 name

-- | Get blob by name in the 'Workspace'

getBlob :: Workspace -> Text -> IO BlobPtr
getBlob (Workspace workspace) name =
  BlobPtr <$> [C.block| void* {
    Workspace *workspace = static_cast<Workspace *>($(void *workspace));
    std::string name($bs-ptr:blobName, $bs-len:blobName);
    Blob *blob = workspace->GetBlob(name);
    return blob;
  }|]
    where
      blobName = encodeUtf8 name

-- | Get the shape of the Tensor stored in the blob pointed to by the 'BlobPtr'

getShape :: BlobPtr -> IO [Int]
getShape (BlobPtr blob) = do
  len <- [C.block| size_t {
      Blob * blob = static_cast<Blob *>($(void * blob));
      return blob->Get<Tensor>().dim();
  }|]
  ptr <- [C.block| const int64_t* {
      Blob * blob = static_cast<Blob *>($(void * blob));
      return blob->Get<Tensor>().sizes().data();
  } |]
  cs <- peekArray (fromIntegral len) ptr
  pure (fromIntegral <$> cs)

----------------------------------------------------------------------------
-- Network operations

-- | Create and add a new network to the 'Workspace'

createNetwork :: Workspace -> ByteString -> IO NetworkPtr
createNetwork (Workspace workspace) netBytes =
      NetworkPtr <$> [C.block| void* {
        Workspace * workspace = static_cast<Workspace *>($(void * workspace));
        NetDef network;
        std::string netString($bs-ptr:netBytes, $bs-len:netBytes);
        CAFFE_ENFORCE(network.ParseFromString(netString));
        NetBase *net = workspace->CreateNet(network);
        CAFFE_ENFORCE(net, "Created network must be non-null");
        return net;
      } |]

-- | Run network without adding it to the 'Workspace'
--
-- This adds the blobs generated by running the network by the
-- network itself is not added to the 'Workspace'

runNetOnce :: Workspace -> ByteString -> IO ()
runNetOnce (Workspace workspace) netBytes =
  [C.block| void {
    Workspace * workspace = static_cast<Workspace *>($(void * workspace));
    NetDef network;
    std::string netString($bs-ptr:netBytes, $bs-len:netBytes);
    CAFFE_ENFORCE(network.ParseFromString(netString));
    CAFFE_ENFORCE(workspace->RunNetOnce(network));
  } |]

-- | Get a network by name from the 'Workspace'

getNetwork :: Workspace -> Text -> IO NetworkPtr
getNetwork (Workspace workspace) netName =
  NetworkPtr <$> [C.block| void* {
    {
      Workspace *workspace = static_cast<Workspace *>($(void * workspace));
      std::string name($bs-ptr:netBytes,$bs-len:netBytes);
      NetBase *net = workspace->GetNet(name);
      return net;
    }
  }|]
  where
    netBytes = encodeUtf8 netName


-- | Run network
--
-- Running a network may also create blobs that are added
-- to the 'Workspace' that contains the network to run.

runNetwork
  :: NetworkPtr                 -- ^ Network pointer
  -> IO ()
runNetwork (NetworkPtr net) =
  [C.block| void {
    {
      NetBase *net = static_cast<NetBase *>($(void *net));
      CAFFE_ENFORCE(net->Run());
    }
  }|]
